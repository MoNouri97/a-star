{"version":3,"sources":["components/grid/node/Node.tsx","components/grid/node/NodeInterface.tsx","components/Algorithm/A*.tsx","components/grid/Grid.tsx","App.tsx","serviceWorker.ts","index.tsx"],"names":["Node","data","mouseDown","mouseUp","mouseEnter","style","delay","animationDelay","className","type","onMouseDown","row","col","onMouseUp","onMouseEnter","equalNodes","a","b","sortByFCost","open","sort","fCost","hCost","getNeighbors","height","width","list","i","j","distanceTo","node","end","rowDifference","Math","abs","colDifference","W","H","START","END","WALL","Grid","getInitialGrid","defaultPoints","grid","currentRow","push","createNode","gCost","Infinity","previous","toggleWall","setGrid","map","gRow","gNode","placeSpecialNode","console","log","start","current","handleMouseDown","setMouseIsPressed","cursor","setCursor","handleMouseUpOrLeave","handleMouseUp","handleMouseEnter","mouseIsPressed","useState","useRef","onMouseLeave","onClick","path","length","closed","lowestFCost","pop","undefined","forEach","neighbor","neighborNode","newGCost","aStar","finalDelay","res","n","inPath","shortestPath","parent","constructPath","setTimeout","indexOf","cleanGrid","key","App","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","message"],"mappings":"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","file":"static/js/main.2dd10628.chunk.js","sourcesContent":["import React from 'react';\n\nimport './node.css';\nimport { INode } from './NodeInterface';\n\ninterface Props {\n\tdata: INode;\n\tmouseDown: (row: number, col: number) => void;\n\tmouseUp: (row: number, col: number) => void;\n\tmouseEnter: (row: number, col: number) => void;\n}\n\nexport const Node: React.FC<Props> = ({\n\tdata,\n\tmouseDown,\n\tmouseUp,\n\tmouseEnter,\n}) => {\n\treturn (\n\t\t<div\n\t\t\tstyle={data.delay ? { animationDelay: data.delay + 'ms' } : {}}\n\t\t\tclassName={`node ${data.type}`}\n\t\t\tonMouseDown={() => mouseDown(data.row, data.col)}\n\t\t\tonMouseUp={() => mouseUp(data.row, data.col)}\n\t\t\tonMouseEnter={() => mouseEnter(data.row, data.col)}\n\t\t></div>\n\t);\n};\n","export interface INode {\n\tcol: number;\n\trow: number;\n\ttype: string;\n\tgCost: number;\n\thCost: number;\n\tfCost: number;\n\tprevious: { row: number; col: number } | null;\n\tdelay?: number | string;\n}\nexport const equalNodes = (a: INode, b: INode) => {\n\treturn a.col === b.col && a.row === b.row;\n};\n","import { INode } from '../grid/node/NodeInterface';\n\nconst COST = 10;\nconst DIAG_COST = 14;\n\nexport const aStar = (grid: INode[][], start: INode, end: INode) => {\n\tconst height = grid.length;\n\tconst width = grid[0].length;\n\n\tlet open: INode[] = [];\n\tlet closed: INode[] = [];\n\tlet current: INode;\n\tlet path: INode[] = [];\n\n\tstart.gCost = 0;\n\topen.push(start);\n\n\twhile (open.length > 0) {\n\t\t// get node with lowest fCost\n\t\tsortByFCost(open);\n\t\tlet lowestFCost = open.pop();\n\t\tif (lowestFCost === undefined) return;\n\t\tcurrent = lowestFCost;\n\t\tif (current.type !== 'start' && current.type !== 'end') {\n\t\t\tcurrent.type = 'closed';\n\t\t\tgrid[current.row][current.col].type = 'closed';\n\t\t}\n\n\t\tclosed = [...closed, current];\n\t\t//track open and close\n\t\tpath = [...path, current];\n\t\tif (current.col === end.col && current.row === end.row) {\n\t\t\tconsole.log('path found');\n\n\t\t\treturn path;\n\t\t}\n\t\tlet neighbors = getNeighbors(current.row, current.col, height, width);\n\n\t\tneighbors.forEach((neighbor) => {\n\t\t\tconst neighborNode = grid[neighbor.row][neighbor.col];\n\t\t\tif (neighborNode.type === 'wall' || neighborNode.type === 'closed')\n\t\t\t\treturn;\n\n\t\t\tconst newGCost = current.gCost + distanceTo(neighborNode, current);\n\n\t\t\tif (neighborNode.gCost > newGCost) {\n\t\t\t\tneighborNode.gCost = newGCost;\n\t\t\t\tneighborNode.hCost = distanceTo(neighborNode, end);\n\t\t\t\tneighborNode.fCost = neighborNode.gCost + neighborNode.hCost;\n\t\t\t\tneighborNode.previous = { row: current.row, col: current.col };\n\t\t\t\tif (neighborNode.type !== 'open') {\n\t\t\t\t\tneighborNode.type = 'open';\n\t\t\t\t\tgrid[neighborNode.row][neighborNode.col].type = 'open';\n\t\t\t\t\topen.push(neighborNode);\n\t\t\t\t\t// path = [...path, neighborNode];\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\tconsole.log('path not found');\n\n\treturn path;\n};\n\nconst sortByFCost = (open: INode[]) => {\n\t/**\n\t * sorting by fCost , if equal by hCost\n\t * a & b are flipped to sort it in descending order\n\t */\n\topen.sort((a, b) => {\n\t\tif (a.fCost !== b.fCost) return b.fCost - a.fCost;\n\t\treturn b.hCost - a.hCost;\n\t});\n};\n\nconst getNeighbors = (\n\trow: number,\n\tcol: number,\n\theight: number,\n\twidth: number,\n) => {\n\tlet list: { row: number; col: number }[] = [];\n\tfor (let i = -1; i < 2; i++) {\n\t\tfor (let j = -1; j < 2; j++) {\n\t\t\tif (i === 0 && j === 0) continue;\n\t\t\tif (row + i >= height || row + i < 0) continue;\n\t\t\tif (col + j >= width || col + j < 0) continue;\n\t\t\tlist = [...list, { row: row + i, col: col + j }];\n\t\t}\n\t}\n\n\treturn list;\n};\n\nconst distanceTo = (node: INode, end: INode) => {\n\tconst rowDifference = Math.abs(node.row - end.row);\n\tconst colDifference = Math.abs(node.col - end.col);\n\n\t/**\n\t * if x > y : 14y + 10(x - y)\n\t */\n\tif (rowDifference > colDifference)\n\t\treturn DIAG_COST * colDifference + COST * (rowDifference - colDifference);\n\n\treturn DIAG_COST * rowDifference + COST * (colDifference - rowDifference);\n};\n","import React, { useState, useRef, useEffect } from 'react';\n\nimport './Grid.css';\nimport { Node } from './node/Node';\nimport { INode, equalNodes } from './node/NodeInterface';\nimport { aStar } from '../Algorithm/A*';\n\n// grid size\nconst W = 40;\nconst H = 20;\n// cursor and nodes\nconst START = 'start';\nconst END = 'end';\nconst WALL = 'wall';\n\nexport const Grid = () => {\n\t// Helpers\n\tconst getInitialGrid = (defaultPoints: boolean = true) => {\n\t\tconst grid = [];\n\t\tfor (let row = 0; row < H; row++) {\n\t\t\tconst currentRow = [];\n\t\t\tfor (let col = 0; col < W; col++) {\n\t\t\t\tcurrentRow.push(createNode(row, col));\n\t\t\t\tif (defaultPoints) {\n\t\t\t\t\tif (row === H / 2 && col === 1) currentRow[col].type = START;\n\t\t\t\t\tif (row === H / 2 && col === W - 2) currentRow[col].type = END;\n\t\t\t\t}\n\t\t\t}\n\t\t\tgrid.push(currentRow);\n\t\t}\n\t\treturn grid;\n\t};\n\n\tconst createNode = (row: number, col: number) => {\n\t\tconst node: INode = {\n\t\t\tcol,\n\t\t\trow,\n\t\t\ttype: ' ', // [wall,visited (closed), calculated (open) , '' (basic),start,end]\n\t\t\tgCost: Infinity,\n\t\t\thCost: Infinity,\n\t\t\tfCost: Infinity,\n\t\t\tprevious: null,\n\t\t};\n\n\t\treturn node;\n\t};\n\n\tconst toggleWall = (row: number, col: number) => {\n\t\tsetGrid(\n\t\t\tgrid.map((gRow) =>\n\t\t\t\tgRow.map((gNode) => {\n\t\t\t\t\tif (gNode.col !== col || gNode.row !== row) return gNode;\n\n\t\t\t\t\tif (gNode.type === WALL) gNode.type = ' ';\n\t\t\t\t\telse if (gNode.type === ' ') gNode.type = WALL;\n\t\t\t\t\treturn gNode;\n\t\t\t\t}),\n\t\t\t),\n\t\t);\n\t};\n\n\tconst placeSpecialNode = (row: number, col: number, type: string = START) => {\n\t\tconsole.log('place', type);\n\n\t\tsetGrid(\n\t\t\tgrid.map((gRow) =>\n\t\t\t\tgRow.map((gNode) => {\n\t\t\t\t\tif ((gNode.col !== col || gNode.row !== row) && gNode.type === type) {\n\t\t\t\t\t\tgNode.type = ' ';\n\t\t\t\t\t\treturn gNode;\n\t\t\t\t\t}\n\t\t\t\t\tif (gNode.type !== ' ') return gNode;\n\t\t\t\t\tif (gNode.col !== col || gNode.row !== row) return gNode;\n\n\t\t\t\t\tgNode.type = type;\n\t\t\t\t\tif (type === START) start.current = gNode;\n\t\t\t\t\tif (type === END) end.current = gNode;\n\t\t\t\t\treturn gNode;\n\t\t\t\t}),\n\t\t\t),\n\t\t);\n\t};\n\n\t/**\n\t * used to copy data from the result of the algorithm to the grid\n\t */\n\tconst inPath = (node: INode, path: INode[]) => {\n\t\tfor (let i = 0; i < path.length; i++) {\n\t\t\tconst n = path[i];\n\t\t\tif (n.col === node.col && n.row === node.row)\n\t\t\t\treturn { previous: n.previous, type: n.type, delay: i * 50 };\n\t\t}\n\t\treturn null;\n\t};\n\tconst constructPath = (node: INode) => {\n\t\tlet path = [node];\n\t\tlet current = path[0];\n\t\twhile (current !== start.current) {\n\t\t\tconst parent = current.previous;\n\t\t\tif (parent === null) {\n\t\t\t\treturn path;\n\t\t\t}\n\t\t\tcurrent = grid[parent.row][parent.col];\n\t\t\tpath = [current, ...path];\n\t\t}\n\t\treturn path;\n\t};\n\n\tconst clearGrid = () => {\n\t\tconst cleanGrid = getInitialGrid(false);\n\t\tsetGrid(\n\t\t\tgrid.map((row, i) =>\n\t\t\t\trow.map((node, j) => {\n\t\t\t\t\tnode = cleanGrid[i][j];\n\n\t\t\t\t\tif (equalNodes(node, start.current)) node.type = START;\n\t\t\t\t\tif (equalNodes(node, end.current)) node.type = END;\n\n\t\t\t\t\treturn node;\n\t\t\t\t}),\n\t\t\t),\n\t\t);\n\t};\n\tconst clearGridKeepWalls = () => {\n\t\tconst cleanGrid = getInitialGrid(false);\n\t\tsetGrid(\n\t\t\tgrid.map((row, i) =>\n\t\t\t\trow.map((node, j) => {\n\t\t\t\t\tif (node.type !== WALL) {\n\t\t\t\t\t\tnode = cleanGrid[i][j];\n\t\t\t\t\t}\n\t\t\t\t\tif (equalNodes(node, start.current)) node.type = START;\n\t\t\t\t\tif (equalNodes(node, end.current)) node.type = END;\n\n\t\t\t\t\treturn node;\n\t\t\t\t}),\n\t\t\t),\n\t\t);\n\t};\n\n\t// events\n\tconst handleMouseDown = (row: number, col: number) => {\n\t\tsetMouseIsPressed(true);\n\n\t\tif (grid[row][col].type === START) {\n\t\t\tsetCursor(START);\n\t\t\treturn;\n\t\t}\n\t\tif (grid[row][col].type === END) {\n\t\t\tsetCursor(END);\n\t\t\treturn;\n\t\t}\n\n\t\tif (cursor === WALL) {\n\t\t\ttoggleWall(row, col);\n\t\t\treturn;\n\t\t}\n\t};\n\tconst handleMouseUpOrLeave = () => {\n\t\tsetMouseIsPressed(false);\n\t};\n\tconst handleMouseUp = (row: number, col: number) => {\n\t\tif (cursor === START) {\n\t\t\tplaceSpecialNode(row, col, START);\n\t\t\tsetCursor(WALL);\n\t\t}\n\t\tif (cursor === END) {\n\t\t\tplaceSpecialNode(row, col, END);\n\t\t\tsetCursor(WALL);\n\t\t}\n\t\tsetMouseIsPressed(false);\n\t};\n\n\tconst handleMouseEnter = (row: number, col: number) => {\n\t\tif (!mouseIsPressed) return;\n\n\t\tif (cursor === WALL) toggleWall(row, col);\n\t\tif (cursor === START) placeSpecialNode(row, col, START);\n\t\tif (cursor === END) placeSpecialNode(row, col, END);\n\t};\n\tconst handleVisualize = () => {\n\t\tconst cloneGrid = grid.map((row) => row.map((node) => node));\n\t\t// get the closed path\n\t\tconst path = aStar(cloneGrid, start.current, end.current);\n\t\tif (path === undefined) {\n\t\t\treturn;\n\t\t}\n\n\t\tlet finalDelay = 0;\n\t\tsetGrid(\n\t\t\tgrid.map((gRow) =>\n\t\t\t\tgRow.map((gNode) => {\n\t\t\t\t\tconst res = inPath(gNode, path);\n\t\t\t\t\tif (res !== null) {\n\t\t\t\t\t\tgNode.type = res.type + '';\n\t\t\t\t\t\tgNode.delay = res.delay;\n\t\t\t\t\t\tgNode.previous = res.previous;\n\t\t\t\t\t\tfinalDelay = res.delay > finalDelay ? res.delay : finalDelay;\n\t\t\t\t\t}\n\t\t\t\t\t// keep the end node\n\t\t\t\t\tif (equalNodes(gNode, end.current)) {\n\t\t\t\t\t\tgNode.type = END;\n\t\t\t\t\t}\n\t\t\t\t\treturn gNode;\n\t\t\t\t}),\n\t\t\t),\n\t\t);\n\t\tif (!equalNodes(path[path.length - 1], end.current)) return;\n\n\t\tconst shortestPath = constructPath(path[path.length - 2]);\n\t\t// animate shortest path\n\t\tsetTimeout(() => {\n\t\t\tsetGrid(\n\t\t\t\tgrid.map((gRow) =>\n\t\t\t\t\tgRow.map((gNode) => {\n\t\t\t\t\t\tconst i = shortestPath.indexOf(gNode);\n\t\t\t\t\t\tif (i > -1) {\n\t\t\t\t\t\t\tif (gNode.type !== START && gNode.type !== END) {\n\t\t\t\t\t\t\t\tgNode.type = 'path';\n\t\t\t\t\t\t\t\tgNode.delay = i * 100;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn gNode;\n\t\t\t\t\t}),\n\t\t\t\t),\n\t\t\t);\n\t\t}, finalDelay + 500);\n\t};\n\n\t// state\n\tconst [grid, setGrid] = useState(getInitialGrid());\n\tconst start = useRef(grid[H / 2][1]);\n\tconst end = useRef(grid[H / 2][W - 2]);\n\tconst [mouseIsPressed, setMouseIsPressed] = useState(false);\n\tconst [cursor, setCursor] = useState(WALL);\n\n\treturn (\n\t\t<div\n\t\t\tclassName='layout'\n\t\t\tonMouseUp={handleMouseUpOrLeave}\n\t\t\tonMouseLeave={handleMouseUpOrLeave}\n\t\t>\n\t\t\t<div className='main'>\n\t\t\t\t<div className='right-side'>\n\t\t\t\t\t<div className='hero is-light'>\n\t\t\t\t\t\t<div className='container'>\n\t\t\t\t\t\t\t<div className='hero-body'>\n\t\t\t\t\t\t\t\t<h1 className='title'>A* Pathfinding</h1>\n\t\t\t\t\t\t\t\t<h2 className='subtitle'>Visualizer</h2>\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t</div>\n\t\t\t\t\t<div className='btn-section box'>\n\t\t\t\t\t\t<div className='btn' onClick={handleVisualize}>\n\t\t\t\t\t\t\tVisualize\n\t\t\t\t\t\t</div>\n\t\t\t\t\t\t<div className='btn' onClick={clearGrid}>\n\t\t\t\t\t\t\tClear\n\t\t\t\t\t\t</div>\n\t\t\t\t\t\t<div className='btn' onClick={clearGridKeepWalls}>\n\t\t\t\t\t\t\tReset\n\t\t\t\t\t\t</div>\n\t\t\t\t\t</div>\n\t\t\t\t</div>\n\n\t\t\t\t<div className='grid box' style={{ width: W * 26 + 'px' }}>\n\t\t\t\t\t{grid.map((row, i) => (\n\t\t\t\t\t\t<div className='row' key={i}>\n\t\t\t\t\t\t\t{row.map((node, j) => {\n\t\t\t\t\t\t\t\treturn (\n\t\t\t\t\t\t\t\t\t<Node\n\t\t\t\t\t\t\t\t\t\tdata={node}\n\t\t\t\t\t\t\t\t\t\tmouseDown={handleMouseDown}\n\t\t\t\t\t\t\t\t\t\tmouseUp={handleMouseUp}\n\t\t\t\t\t\t\t\t\t\tmouseEnter={handleMouseEnter}\n\t\t\t\t\t\t\t\t\t\tkey={i + ',' + j}\n\t\t\t\t\t\t\t\t\t></Node>\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t})}\n\t\t\t\t\t\t</div>\n\t\t\t\t\t))}\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t</div>\n\t);\n};\n","import React from 'react';\n// import logo from './logo.svg';\nimport './App.css';\nimport { Grid } from './components/grid/Grid';\n\nfunction App() {\n\treturn (\n\t\t<div className='App'>\n\t\t\t<Grid></Grid>\n\t\t</div>\n\t);\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport '../node_modules/bulma/css/bulma.css';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n\t<React.StrictMode>\n\t\t<App />\n\t</React.StrictMode>,\n\tdocument.getElementById('root'),\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}