{"version":3,"sources":["components/grid/node/Node.tsx","components/grid/node/NodeInterface.tsx","components/Algorithm/A*.tsx","components/Algorithm/Djikstra.ts","components/grid/Grid.tsx","components/useCheckbox.ts","components/Algorithm/RandomWalls.tsx","App.tsx","serviceWorker.ts","index.tsx"],"names":["Node","data","mouseDown","mouseUp","mouseEnter","style","delay","animationDelay","className","type","onMouseDown","event","preventDefault","row","col","onMouseUp","onMouseEnter","equalNodes","a","b","createNode","gCost","Infinity","hCost","fCost","previous","DIAG","sortByFCost","open","sort","getNeighbors","height","width","allowDiag","list","i","j","distanceTo","node","end","rowDifference","Math","abs","colDifference","W","H","START","END","WALL","SLOW_SPEED","FAST_SPEED","Grid","toggleWall","setGrid","grid","map","gRow","gNode","placeSpecialNode","console","log","start","current","clearGrid","keepWalls","pathAnimation","clearTimeout","setPathFound","handleMouseDown","setMouseIsPressed","cursor","setCursor","handleMouseUpOrLeave","handleMouseUp","handleMouseEnter","mouseIsPressed","handleVisualize","algorithm","path","cloneGrid","length","closed","push","lowestFCost","pop","undefined","neighbors","forEach","neighbor","neighborNode","newGCost","aStar","checked","dijkstra","finalDelay","res","n","searchSpeed","inPath","shortestPath","parent","constructPath","setTimeout","indexOf","pathSpeed","alert","useState","defaultPoints","currentRow","getInitialGrid","useRef","initial","setValue","onChange","e","useCheckbox","pathFound","onMouseLeave","htmlFor","defaultValue","target","value","onClick","disabled","newGrid","cols","rows","wall","random","randomWalls","key","App","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","message"],"mappings":"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","file":"static/js/main.98048139.chunk.js","sourcesContent":["import React from 'react';\n\nimport './node.css';\nimport { INode } from './NodeInterface';\n\ninterface Props {\n\tdata: INode;\n\tmouseDown: (row: number, col: number) => void;\n\tmouseUp: (row: number, col: number) => void;\n\tmouseEnter: (row: number, col: number) => void;\n}\n\nexport const Node: React.FC<Props> = ({\n\tdata,\n\tmouseDown,\n\tmouseUp,\n\tmouseEnter,\n}) => {\n\treturn (\n\t\t<div\n\t\t\tstyle={data.delay ? { animationDelay: data.delay + 'ms' } : {}}\n\t\t\tclassName={`node ${data.type}`}\n\t\t\tonMouseDown={(event) => {\n\t\t\t\tevent.preventDefault();\n\t\t\t\tmouseDown(data.row, data.col);\n\t\t\t}}\n\t\t\tonMouseUp={() => mouseUp(data.row, data.col)}\n\t\t\tonMouseEnter={() => mouseEnter(data.row, data.col)}\n\t\t></div>\n\t);\n};\n","export interface INode {\n\tcol: number;\n\trow: number;\n\ttype: string;\n\tgCost: number;\n\thCost: number;\n\tfCost: number;\n\tprevious: { row: number; col: number } | null;\n\tdelay?: number | string;\n}\nexport const equalNodes = (a: INode, b: INode) => {\n\treturn a.col === b.col && a.row === b.row;\n};\n\nexport const createNode = (row: number, col: number, type?: string) => {\n\tconst node: INode = {\n\t\tcol,\n\t\trow,\n\t\ttype: type ? type : ' ', // [wall,visited (closed), calculated (open) , '' (basic),start,end]\n\t\tgCost: Infinity,\n\t\thCost: Infinity,\n\t\tfCost: Infinity,\n\t\tprevious: null,\n\t};\n\n\treturn node;\n};\n","import { INode } from '../grid/node/NodeInterface';\n\nconst COST = 10;\nconst DIAG_COST = 14;\nlet DIAG = false;\n\nexport const aStar = (\n\tgrid: INode[][],\n\tstart: INode,\n\tend: INode,\n\tallowDiag = false,\n) => {\n\tDIAG = allowDiag;\n\tconst height = grid.length;\n\tconst width = grid[0].length;\n\n\tlet open: INode[] = [];\n\tlet closed: INode[] = [];\n\tlet current: INode;\n\tlet path: INode[] = [];\n\n\tstart.gCost = 0;\n\topen.push(start);\n\n\twhile (open.length > 0) {\n\t\t// get node with lowest fCost\n\t\tsortByFCost(open);\n\t\tlet lowestFCost = open.pop();\n\t\tif (lowestFCost === undefined) return;\n\t\tcurrent = lowestFCost;\n\t\tif (current.type !== 'start' && current.type !== 'end') {\n\t\t\tcurrent.type = 'closed';\n\t\t\tgrid[current.row][current.col].type = 'closed';\n\t\t}\n\n\t\tclosed = [...closed, current];\n\t\t//track open and close\n\t\tpath = [...path, current];\n\t\tif (current.col === end.col && current.row === end.row) {\n\t\t\tconsole.log('path found');\n\n\t\t\treturn path;\n\t\t}\n\t\tlet neighbors = getNeighbors(\n\t\t\tcurrent.row,\n\t\t\tcurrent.col,\n\t\t\theight,\n\t\t\twidth,\n\t\t\tallowDiag,\n\t\t);\n\n\t\tneighbors.forEach(neighbor => {\n\t\t\tconst neighborNode = grid[neighbor.row][neighbor.col];\n\t\t\tif (neighborNode.type === 'wall' || neighborNode.type === 'closed')\n\t\t\t\treturn;\n\t\t\tconst newGCost = current.gCost + distanceTo(neighborNode, current);\n\t\t\tif (neighborNode.gCost > newGCost) {\n\t\t\t\tneighborNode.gCost = newGCost;\n\t\t\t\tneighborNode.hCost = distanceTo(neighborNode, end);\n\t\t\t\tneighborNode.fCost = neighborNode.gCost + neighborNode.hCost;\n\t\t\t\tneighborNode.previous = { row: current.row, col: current.col };\n\t\t\t\tif (neighborNode.type !== 'open') {\n\t\t\t\t\tneighborNode.type = 'open';\n\t\t\t\t\tgrid[neighborNode.row][neighborNode.col].type = 'open';\n\t\t\t\t\topen.push(neighborNode);\n\t\t\t\t\t// path = [...path, neighborNode];\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\tconsole.log('path not found');\n\n\treturn path;\n};\n\nconst sortByFCost = (open: INode[]) => {\n\t/**\n\t * sorting by fCost , if equal by hCost\n\t * a & b are flipped to sort it in descending order\n\t */\n\topen.sort((a, b) => {\n\t\tif (a.fCost !== b.fCost) return b.fCost - a.fCost;\n\t\treturn b.hCost - a.hCost;\n\t});\n};\n\nconst getNeighbors = (\n\trow: number,\n\tcol: number,\n\theight: number,\n\twidth: number,\n\tallowDiag = false,\n) => {\n\tlet list: { row: number; col: number }[] = [];\n\tfor (let i = -1; i < 2; i++) {\n\t\tfor (let j = -1; j < 2; j++) {\n\t\t\tif (!allowDiag && i !== 0 && j !== 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (i === 0 && j === 0) continue;\n\t\t\tif (row + i >= height || row + i < 0) continue;\n\t\t\tif (col + j >= width || col + j < 0) continue;\n\t\t\tlist = [...list, { row: row + i, col: col + j }];\n\t\t}\n\t}\n\n\treturn list;\n};\n\nconst distanceTo = (node: INode, end: INode) => {\n\tconst rowDifference = Math.abs(node.row - end.row);\n\tconst colDifference = Math.abs(node.col - end.col);\n\tif (!DIAG) {\n\t\treturn COST * (colDifference + rowDifference);\n\t}\n\t/**\n\t * if x > y : 14y + 10(x - y)\n\t */\n\tif (rowDifference > colDifference)\n\t\treturn DIAG_COST * colDifference + COST * (rowDifference - colDifference);\n\n\treturn DIAG_COST * rowDifference + COST * (colDifference - rowDifference);\n};\n","import { INode } from '../grid/node/NodeInterface';\n\nconst COST = 10;\nconst DIAG_COST = 14;\nlet DIAG = false;\n\nexport const dijkstra = (\n\tgrid: INode[][],\n\tstart: INode,\n\tend: INode,\n\tallowDiag = false,\n) => {\n\tDIAG = allowDiag;\n\tconst height = grid.length;\n\tconst width = grid[0].length;\n\n\tlet open: INode[] = [];\n\tlet closed: INode[] = [];\n\tlet current: INode;\n\tlet path: INode[] = [];\n\n\tstart.gCost = 0;\n\topen.push(start);\n\n\twhile (open.length > 0) {\n\t\t// get node with lowest fCost\n\t\tsortByFCost(open);\n\t\tlet lowestFCost = open.pop();\n\t\tif (lowestFCost === undefined) return;\n\t\tcurrent = lowestFCost;\n\t\tif (current.type !== 'start' && current.type !== 'end') {\n\t\t\tcurrent.type = 'closed';\n\t\t\t// grid[current.row][current.col].type = 'closed';\n\t\t}\n\n\t\tclosed = [...closed, current];\n\t\t//track open and close\n\t\tpath = [...path, current];\n\t\tif (current.col === end.col && current.row === end.row) {\n\t\t\tconsole.log('path found');\n\t\t\treturn path;\n\t\t}\n\n\t\tlet neighbors = getNeighbors(\n\t\t\tcurrent.row,\n\t\t\tcurrent.col,\n\t\t\theight,\n\t\t\twidth,\n\t\t\tallowDiag,\n\t\t);\n\n\t\tneighbors.forEach(neighbor => {\n\t\t\tconst neighborNode = grid[neighbor.row][neighbor.col];\n\t\t\tif (neighborNode.type === 'wall' || neighborNode.type === 'closed')\n\t\t\t\treturn;\n\t\t\tconst newGCost = current.gCost + distanceTo(neighborNode, current);\n\t\t\tif (neighborNode.gCost > newGCost) {\n\t\t\t\tneighborNode.gCost = newGCost;\n\t\t\t\t// neighborNode.hCost = distanceTo(neighborNode, end);\n\t\t\t\t// unlike a* dijkstra does not use an h cost\n\t\t\t\tneighborNode.hCost = 0;\n\t\t\t\tneighborNode.fCost = neighborNode.gCost;\n\t\t\t\tneighborNode.previous = { row: current.row, col: current.col };\n\t\t\t\tif (neighborNode.type !== 'open') {\n\t\t\t\t\tneighborNode.type = 'open';\n\t\t\t\t\tgrid[neighborNode.row][neighborNode.col].type = 'open';\n\t\t\t\t\topen.push(neighborNode);\n\t\t\t\t\t// path = [...path, neighborNode];\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\tconsole.log('path not found');\n\n\treturn path;\n};\n\nconst sortByFCost = (open: INode[]) => {\n\t/**\n\t * sorting by fCost , if equal by hCost\n\t * a & b are flipped to sort it in descending order\n\t */\n\topen.sort((a, b) => {\n\t\tif (a.fCost !== b.fCost) return b.fCost - a.fCost;\n\t\treturn b.hCost - a.hCost;\n\t});\n};\n\nconst getNeighbors = (\n\trow: number,\n\tcol: number,\n\theight: number,\n\twidth: number,\n\tallowDiag = false,\n) => {\n\tlet list: { row: number; col: number }[] = [];\n\tfor (let i = -1; i < 2; i++) {\n\t\tfor (let j = -1; j < 2; j++) {\n\t\t\t// diagonal check\n\t\t\tif (!allowDiag && i !== 0 && j !== 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t// current node\n\t\t\tif (i === 0 && j === 0) continue;\n\t\t\t// outside of the grid\n\t\t\tif (row + i >= height || row + i < 0) continue;\n\t\t\tif (col + j >= width || col + j < 0) continue;\n\n\t\t\tlist = [...list, { row: row + i, col: col + j }];\n\t\t}\n\t}\n\n\treturn list;\n};\n\nconst distanceTo = (node: INode, end: INode) => {\n\tconst rowDifference = Math.abs(node.row - end.row);\n\tconst colDifference = Math.abs(node.col - end.col);\n\tif (!DIAG) {\n\t\treturn COST * (colDifference + rowDifference);\n\t}\n\t/**\n\t * if x > y : 14y + 10(x - y)\n\t */\n\tif (rowDifference > colDifference)\n\t\treturn DIAG_COST * colDifference + COST * (rowDifference - colDifference);\n\n\treturn DIAG_COST * rowDifference + COST * (colDifference - rowDifference);\n};\n","import React, { useState, useRef, ChangeEvent } from 'react';\n\nimport './Grid.css';\nimport { Node } from './node/Node';\nimport { INode, equalNodes, createNode } from './node/NodeInterface';\nimport { aStar } from '../Algorithm/A*';\nimport { randomWalls } from '../Algorithm/RandomWalls';\nimport { useCheckbox } from '../useCheckbox';\nimport { dijkstra } from '../Algorithm/Djikstra';\n\n// grid size\nconst W = 40;\nconst H = 20;\n// cursor and nodes\nconst START = 'start';\nconst END = 'end';\nconst WALL = 'wall';\n// animation Speed\nconst SLOW_SPEED = {\n\tSEARCH: 50,\n\tPATH: 100,\n};\nconst FAST_SPEED = {\n\tSEARCH: 20,\n\tPATH: 50,\n};\n\nexport const Grid = () => {\n\t// Helpers\n\tconst getInitialGrid = (defaultPoints: boolean = true) => {\n\t\tconst grid = [];\n\t\tfor (let row = 0; row < H; row++) {\n\t\t\tconst currentRow = [];\n\t\t\tfor (let col = 0; col < W; col++) {\n\t\t\t\tcurrentRow.push(createNode(row, col));\n\t\t\t\tif (defaultPoints) {\n\t\t\t\t\tif (row === H / 2 && col === 1) currentRow[col].type = START;\n\t\t\t\t\tif (row === H / 2 && col === W - 2) currentRow[col].type = END;\n\t\t\t\t}\n\t\t\t}\n\t\t\tgrid.push(currentRow);\n\t\t}\n\t\treturn grid;\n\t};\n\n\tconst toggleWall = (row: number, col: number) => {\n\t\tsetGrid(\n\t\t\tgrid.map(gRow =>\n\t\t\t\tgRow.map(gNode => {\n\t\t\t\t\tif (gNode.col !== col || gNode.row !== row) return gNode;\n\n\t\t\t\t\tif (gNode.type === WALL) gNode.type = ' ';\n\t\t\t\t\telse if (gNode.type === ' ') gNode.type = WALL;\n\t\t\t\t\treturn gNode;\n\t\t\t\t}),\n\t\t\t),\n\t\t);\n\t};\n\n\tconst placeSpecialNode = (row: number, col: number, type: string = START) => {\n\t\tconsole.log('place', type);\n\n\t\tsetGrid(\n\t\t\tgrid.map(gRow =>\n\t\t\t\tgRow.map(gNode => {\n\t\t\t\t\tif ((gNode.col !== col || gNode.row !== row) && gNode.type === type) {\n\t\t\t\t\t\tgNode.type = ' ';\n\t\t\t\t\t\treturn gNode;\n\t\t\t\t\t}\n\t\t\t\t\tif (gNode.type !== ' ') return gNode;\n\t\t\t\t\tif (gNode.col !== col || gNode.row !== row) return gNode;\n\n\t\t\t\t\tgNode.type = type;\n\t\t\t\t\tif (type === START) start.current = gNode;\n\t\t\t\t\tif (type === END) end.current = gNode;\n\t\t\t\t\treturn gNode;\n\t\t\t\t}),\n\t\t\t),\n\t\t);\n\t};\n\n\t/**\n\t * used to copy data from the result of the algorithm to the grid\n\t */\n\tconst inPath = (node: INode, path: INode[]) => {\n\t\tfor (let i = 0; i < path.length; i++) {\n\t\t\tconst n = path[i];\n\t\t\tif (n.col === node.col && n.row === node.row)\n\t\t\t\treturn {\n\t\t\t\t\tprevious: n.previous,\n\t\t\t\t\ttype: n.type,\n\t\t\t\t\tdelay: i * searchSpeed.current,\n\t\t\t\t};\n\t\t}\n\t\treturn null;\n\t};\n\tconst constructPath = (node: INode) => {\n\t\tlet path = [node];\n\t\tlet current = path[0];\n\t\twhile (current !== start.current) {\n\t\t\tconst parent = current.previous;\n\t\t\tif (parent === null) {\n\t\t\t\treturn path;\n\t\t\t}\n\t\t\tcurrent = grid[parent.row][parent.col];\n\t\t\tpath = [current, ...path];\n\t\t}\n\t\treturn path;\n\t};\n\n\tconst clearGrid = (keepWalls = false) => {\n\t\t// used later to animate path\n\t\tif (pathAnimation.current) clearTimeout(pathAnimation.current);\n\t\tsetGrid(\n\t\t\tgrid.map((row, i) =>\n\t\t\t\trow.map((node, j) => {\n\t\t\t\t\tif (!keepWalls || node.type !== WALL) {\n\t\t\t\t\t\tnode = createNode(i, j);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (equalNodes(node, start.current)) node.type = START;\n\t\t\t\t\tif (equalNodes(node, end.current)) node.type = END;\n\n\t\t\t\t\treturn node;\n\t\t\t\t}),\n\t\t\t),\n\t\t);\n\t\tsetPathFound(false);\n\t};\n\n\t// events\n\tconst handleMouseDown = (row: number, col: number) => {\n\t\tsetMouseIsPressed(true);\n\n\t\tif (grid[row][col].type === START) {\n\t\t\tsetCursor(START);\n\t\t\treturn;\n\t\t}\n\t\tif (grid[row][col].type === END) {\n\t\t\tsetCursor(END);\n\t\t\treturn;\n\t\t}\n\n\t\tif (cursor === WALL) {\n\t\t\ttoggleWall(row, col);\n\t\t\treturn;\n\t\t}\n\t};\n\tconst handleMouseUpOrLeave = () => {\n\t\tsetMouseIsPressed(false);\n\t};\n\tconst handleMouseUp = (row: number, col: number) => {\n\t\tif (cursor === START) {\n\t\t\tplaceSpecialNode(row, col, START);\n\t\t\tsetCursor(WALL);\n\t\t}\n\t\tif (cursor === END) {\n\t\t\tplaceSpecialNode(row, col, END);\n\t\t\tsetCursor(WALL);\n\t\t}\n\t\tsetMouseIsPressed(false);\n\t};\n\n\tconst handleMouseEnter = (row: number, col: number) => {\n\t\tif (!mouseIsPressed) return;\n\n\t\tif (cursor === WALL) toggleWall(row, col);\n\t\tif (cursor === START) placeSpecialNode(row, col, START);\n\t\tif (cursor === END) placeSpecialNode(row, col, END);\n\t};\n\tconst handleVisualize = (algorithm: 'astar' | 'dijkstra') => {\n\t\t// used later to animate path\n\t\tif (pathAnimation.current) clearTimeout(pathAnimation.current);\n\n\t\tconst cloneGrid = grid.map(row =>\n\t\t\trow.map(node => createNode(node.row, node.col, node.type)),\n\t\t);\n\t\t// get the closed path\n\t\tlet path: INode[] | undefined;\n\t\tswitch (algorithm) {\n\t\t\tcase 'astar':\n\t\t\t\tpath = aStar(cloneGrid, start.current, end.current, allowDiag.checked);\n\t\t\t\tbreak;\n\t\t\tcase 'dijkstra':\n\t\t\t\tpath = dijkstra(\n\t\t\t\t\tcloneGrid,\n\t\t\t\t\tstart.current,\n\t\t\t\t\tend.current,\n\t\t\t\t\tallowDiag.checked,\n\t\t\t\t);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (path === undefined) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (!equalNodes(path[path.length - 1], end.current)) {\n\t\t\talert('no path found');\n\t\t\treturn;\n\t\t}\n\t\tsetPathFound(true);\n\n\t\tlet finalDelay = 0;\n\t\tsetGrid(\n\t\t\tgrid.map(gRow =>\n\t\t\t\tgRow.map(gNode => {\n\t\t\t\t\tconst res = inPath(gNode, path!);\n\t\t\t\t\tif (res !== null) {\n\t\t\t\t\t\tgNode.type = res.type + '';\n\t\t\t\t\t\tgNode.delay = res.delay;\n\t\t\t\t\t\tgNode.previous = res.previous;\n\t\t\t\t\t\tfinalDelay = res.delay > finalDelay ? res.delay : finalDelay;\n\t\t\t\t\t}\n\t\t\t\t\t// keep the end node\n\t\t\t\t\tif (equalNodes(gNode, end.current)) {\n\t\t\t\t\t\tgNode.type = END;\n\t\t\t\t\t}\n\t\t\t\t\treturn gNode;\n\t\t\t\t}),\n\t\t\t),\n\t\t);\n\n\t\tconst shortestPath = constructPath(path[path.length - 1]);\n\t\t// animate shortest path\n\t\tpathAnimation.current = setTimeout(() => {\n\t\t\tsetGrid(\n\t\t\t\tgrid.map(gRow =>\n\t\t\t\t\tgRow.map(gNode => {\n\t\t\t\t\t\tconst i = shortestPath.indexOf(gNode);\n\t\t\t\t\t\tif (i > -1) {\n\t\t\t\t\t\t\tif (gNode.type !== START && gNode.type !== END) {\n\t\t\t\t\t\t\t\tgNode.type = 'path';\n\t\t\t\t\t\t\t\tgNode.delay = i * pathSpeed.current;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn gNode;\n\t\t\t\t\t}),\n\t\t\t\t),\n\t\t\t);\n\t\t}, finalDelay + 500);\n\t};\n\n\tconst handleRandomMaze = () => {\n\t\tconst newGrid = randomWalls(W, H);\n\t\tclearGrid();\n\t\tsetTimeout(() => {\n\t\t\tsetGrid(\n\t\t\t\tgrid.map((gRow, i) =>\n\t\t\t\t\tgRow.map((gNode, j) => {\n\t\t\t\t\t\tgNode = createNode(i, j);\n\n\t\t\t\t\t\tif (equalNodes(gNode, start.current)) {\n\t\t\t\t\t\t\tgNode.type = START;\n\t\t\t\t\t\t\treturn gNode;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (equalNodes(gNode, end.current)) {\n\t\t\t\t\t\t\tgNode.type = END;\n\t\t\t\t\t\t\treturn gNode;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst res = newGrid[i][j];\n\t\t\t\t\t\tif (!res.wall) {\n\t\t\t\t\t\t\treturn gNode;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tgNode.type = WALL;\n\t\t\t\t\t\tgNode.delay = res.delay;\n\n\t\t\t\t\t\treturn gNode;\n\t\t\t\t\t}),\n\t\t\t\t),\n\t\t\t);\n\t\t}, 20);\n\t};\n\tconst handleSpeedChange = (event: ChangeEvent<HTMLSelectElement>) => {\n\t\tconsole.log(event.target.value);\n\n\t\tif (event.target.value === 'fast') {\n\t\t\tsearchSpeed.current = FAST_SPEED.SEARCH;\n\t\t\tpathSpeed.current = FAST_SPEED.PATH;\n\t\t}\n\t\tif (event.target.value === 'slow') {\n\t\t\tsearchSpeed.current = SLOW_SPEED.SEARCH;\n\t\t\tpathSpeed.current = SLOW_SPEED.PATH;\n\t\t}\n\t};\n\t// state & refs\n\tconst [grid, setGrid] = useState(getInitialGrid());\n\tconst start = useRef(grid[H / 2][1]);\n\tconst end = useRef(grid[H / 2][W - 2]);\n\tconst [mouseIsPressed, setMouseIsPressed] = useState(false);\n\tconst [cursor, setCursor] = useState(WALL);\n\tconst searchSpeed = useRef(FAST_SPEED.SEARCH);\n\tconst pathSpeed = useRef(FAST_SPEED.PATH);\n\tconst pathAnimation = useRef<NodeJS.Timeout>();\n\tconst allowDiag = useCheckbox(false);\n\tconst [pathFound, setPathFound] = useState(false);\n\n\treturn (\n\t\t<div\n\t\t\tclassName='layout'\n\t\t\tonMouseUp={handleMouseUpOrLeave}\n\t\t\tonMouseLeave={handleMouseUpOrLeave}\n\t\t>\n\t\t\t<div className='main columns'>\n\t\t\t\t<div className='right-side column'>\n\t\t\t\t\t<div className='btn-section'>\n\t\t\t\t\t\t<div className='subtitle is-6'>Visualize Algorithm</div>\n\t\t\t\t\t\t<div className='field mb-3'>\n\t\t\t\t\t\t\t<div className='control'>\n\t\t\t\t\t\t\t\t<label htmlFor='select'>Speed : </label>\n\t\t\t\t\t\t\t\t<div className='select is-small'>\n\t\t\t\t\t\t\t\t\t<select defaultValue='fast' onChange={handleSpeedChange}>\n\t\t\t\t\t\t\t\t\t\t<option value='slow'>Slow</option>\n\t\t\t\t\t\t\t\t\t\t<option value='fast'>Fast</option>\n\t\t\t\t\t\t\t\t\t</select>\n\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t<label className='checkbox'>\n\t\t\t\t\t\t\t\t<input type='checkbox' {...allowDiag} />\n\t\t\t\t\t\t\t\tAllow Diagonal\n\t\t\t\t\t\t\t</label>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t\t<button\n\t\t\t\t\t\t\tclassName='button'\n\t\t\t\t\t\t\tonClick={() => handleVisualize('astar')}\n\t\t\t\t\t\t\tdisabled={pathFound}\n\t\t\t\t\t\t>\n\t\t\t\t\t\t\tA*\n\t\t\t\t\t\t</button>\n\t\t\t\t\t\t<button\n\t\t\t\t\t\t\tclassName='button'\n\t\t\t\t\t\t\tonClick={() => handleVisualize('dijkstra')}\n\t\t\t\t\t\t\tdisabled={pathFound}\n\t\t\t\t\t\t>\n\t\t\t\t\t\t\tDijkstra\n\t\t\t\t\t\t</button>\n\t\t\t\t\t\t<div className='subtitle is-6'>Grid</div>\n\t\t\t\t\t\t<div className='button' onClick={() => clearGrid(false)}>\n\t\t\t\t\t\t\tClear Walls\n\t\t\t\t\t\t</div>\n\t\t\t\t\t\t<div className='button' onClick={() => clearGrid(true)}>\n\t\t\t\t\t\t\tReset Path\n\t\t\t\t\t\t</div>\n\t\t\t\t\t\t<div className='subtitle is-6'>Maze Generation</div>\n\t\t\t\t\t\t<div className='button' onClick={handleRandomMaze}>\n\t\t\t\t\t\t\tRandom\n\t\t\t\t\t\t</div>\n\t\t\t\t\t</div>\n\t\t\t\t</div>\n\n\t\t\t\t<div\n\t\t\t\t\tclassName='grid box column is-12 is-9-desktop'\n\t\t\t\t\t// style={{ width: W * 26 + 'px' }}\n\t\t\t\t>\n\t\t\t\t\t{grid.map((row, i) => (\n\t\t\t\t\t\t<div className='row' key={i}>\n\t\t\t\t\t\t\t{row.map((node, j) => {\n\t\t\t\t\t\t\t\treturn (\n\t\t\t\t\t\t\t\t\t<Node\n\t\t\t\t\t\t\t\t\t\tdata={node}\n\t\t\t\t\t\t\t\t\t\tmouseDown={handleMouseDown}\n\t\t\t\t\t\t\t\t\t\tmouseUp={handleMouseUp}\n\t\t\t\t\t\t\t\t\t\tmouseEnter={handleMouseEnter}\n\t\t\t\t\t\t\t\t\t\tkey={i + ',' + j}\n\t\t\t\t\t\t\t\t\t></Node>\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t})}\n\t\t\t\t\t\t</div>\n\t\t\t\t\t))}\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t</div>\n\t);\n};\n","import { useState } from 'react';\n\nexport const useCheckbox = (initial: boolean) => {\n\tconst [checked, setValue] = useState(initial);\n\tconst onChange = (e: React.ChangeEvent<any>) => {\n\t\tsetValue(!checked);\n\t};\n\n\treturn {\n\t\tchecked,\n\t\tonChange,\n\t};\n};\n","export const randomWalls: (\n\tcols: number,\n\trows: number,\n) => {\n\twall: boolean;\n\tdelay: number;\n}[][] = (cols: number, rows: number) => {\n\tconst grid = [];\n\tfor (let row = 0; row < rows; row++) {\n\t\tconst currentRow = [];\n\t\tfor (let col = 0; col < cols; col++) {\n\t\t\tcurrentRow.push({\n\t\t\t\twall: false,\n\t\t\t\tdelay: 0,\n\t\t\t});\n\t\t\tif (Math.random() < 0.5) {\n\t\t\t\tcurrentRow[col].delay = (col + row) * 50;\n\t\t\t\tcurrentRow[col].wall = true;\n\t\t\t}\n\t\t}\n\t\tgrid.push(currentRow);\n\t}\n\treturn grid;\n};\n","import React from 'react';\n// import logo from './logo.svg';\nimport './App.css';\nimport { Grid } from './components/grid/Grid';\n\nfunction App() {\n\treturn (\n\t\t<div className='App'>\n\t\t\t<Grid></Grid>\n\t\t</div>\n\t);\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport '../node_modules/bulma/css/bulma.css';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n\t<React.StrictMode>\n\t\t<App />\n\t</React.StrictMode>,\n\tdocument.getElementById('root'),\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}