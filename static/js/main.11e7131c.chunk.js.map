{"version":3,"sources":["components/grid/node/Node.tsx","components/grid/node/NodeInterface.tsx","components/Algorithm/A*.tsx","components/grid/Grid.tsx","components/useCheckbox.ts","components/Algorithm/RandomWalls.tsx","App.tsx","serviceWorker.ts","index.tsx"],"names":["Node","data","mouseDown","mouseUp","mouseEnter","style","delay","animationDelay","className","type","onMouseDown","event","preventDefault","row","col","onMouseUp","onMouseEnter","equalNodes","a","b","createNode","gCost","Infinity","hCost","fCost","previous","DIAG","sortByFCost","open","sort","getNeighbors","height","width","allowDiag","list","i","j","distanceTo","node","end","rowDifference","Math","abs","colDifference","W","H","START","END","WALL","SLOW_SPEED","FAST_SPEED","Grid","toggleWall","setGrid","grid","map","gRow","gNode","placeSpecialNode","console","log","start","current","clearGrid","setPathFound","handleMouseDown","setMouseIsPressed","cursor","setCursor","handleMouseUpOrLeave","handleMouseUp","handleMouseEnter","mouseIsPressed","useState","defaultPoints","currentRow","push","getInitialGrid","useRef","searchSpeed","pathSpeed","initial","checked","setValue","onChange","e","useCheckbox","pathFound","onMouseLeave","htmlFor","defaultValue","target","value","onClick","cloneGrid","path","length","closed","lowestFCost","pop","undefined","neighbors","forEach","neighbor","neighborNode","newGCost","aStar","finalDelay","res","n","inPath","shortestPath","parent","constructPath","setTimeout","indexOf","alert","disabled","newGrid","cols","rows","wall","random","randomWalls","key","App","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","message"],"mappings":"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","file":"static/js/main.11e7131c.chunk.js","sourcesContent":["import React from 'react';\n\nimport './node.css';\nimport { INode } from './NodeInterface';\n\ninterface Props {\n\tdata: INode;\n\tmouseDown: (row: number, col: number) => void;\n\tmouseUp: (row: number, col: number) => void;\n\tmouseEnter: (row: number, col: number) => void;\n}\n\nexport const Node: React.FC<Props> = ({\n\tdata,\n\tmouseDown,\n\tmouseUp,\n\tmouseEnter,\n}) => {\n\treturn (\n\t\t<div\n\t\t\tstyle={data.delay ? { animationDelay: data.delay + 'ms' } : {}}\n\t\t\tclassName={`node ${data.type}`}\n\t\t\tonMouseDown={(event) => {\n\t\t\t\tevent.preventDefault();\n\t\t\t\tmouseDown(data.row, data.col);\n\t\t\t}}\n\t\t\tonMouseUp={() => mouseUp(data.row, data.col)}\n\t\t\tonMouseEnter={() => mouseEnter(data.row, data.col)}\n\t\t></div>\n\t);\n};\n","export interface INode {\n\tcol: number;\n\trow: number;\n\ttype: string;\n\tgCost: number;\n\thCost: number;\n\tfCost: number;\n\tprevious: { row: number; col: number } | null;\n\tdelay?: number | string;\n}\nexport const equalNodes = (a: INode, b: INode) => {\n\treturn a.col === b.col && a.row === b.row;\n};\n\nexport const createNode = (row: number, col: number) => {\n\tconst node: INode = {\n\t\tcol,\n\t\trow,\n\t\ttype: ' ', // [wall,visited (closed), calculated (open) , '' (basic),start,end]\n\t\tgCost: Infinity,\n\t\thCost: Infinity,\n\t\tfCost: Infinity,\n\t\tprevious: null,\n\t};\n\n\treturn node;\n};\n","import { INode } from '../grid/node/NodeInterface';\n\nconst COST = 10;\nconst DIAG_COST = 14;\nlet DIAG = false;\n\nexport const aStar = (\n\tgrid: INode[][],\n\tstart: INode,\n\tend: INode,\n\tallowDiag = false,\n) => {\n\tDIAG = allowDiag;\n\tconst height = grid.length;\n\tconst width = grid[0].length;\n\n\tlet open: INode[] = [];\n\tlet closed: INode[] = [];\n\tlet current: INode;\n\tlet path: INode[] = [];\n\n\tstart.gCost = 0;\n\topen.push(start);\n\n\twhile (open.length > 0) {\n\t\t// get node with lowest fCost\n\t\tsortByFCost(open);\n\t\tlet lowestFCost = open.pop();\n\t\tif (lowestFCost === undefined) return;\n\t\tcurrent = lowestFCost;\n\t\tif (current.type !== 'start' && current.type !== 'end') {\n\t\t\tcurrent.type = 'closed';\n\t\t\tgrid[current.row][current.col].type = 'closed';\n\t\t}\n\n\t\tclosed = [...closed, current];\n\t\t//track open and close\n\t\tpath = [...path, current];\n\t\tif (current.col === end.col && current.row === end.row) {\n\t\t\tconsole.log('path found');\n\n\t\t\treturn path;\n\t\t}\n\t\tlet neighbors = getNeighbors(\n\t\t\tcurrent.row,\n\t\t\tcurrent.col,\n\t\t\theight,\n\t\t\twidth,\n\t\t\tallowDiag,\n\t\t);\n\n\t\tneighbors.forEach(neighbor => {\n\t\t\tconst neighborNode = grid[neighbor.row][neighbor.col];\n\t\t\tif (neighborNode.type === 'wall' || neighborNode.type === 'closed')\n\t\t\t\treturn;\n\t\t\tconst newGCost = current.gCost + distanceTo(neighborNode, current);\n\t\t\tif (neighborNode.gCost > newGCost) {\n\t\t\t\tneighborNode.gCost = newGCost;\n\t\t\t\tneighborNode.hCost = distanceTo(neighborNode, end);\n\t\t\t\tneighborNode.fCost = neighborNode.gCost + neighborNode.hCost;\n\t\t\t\tneighborNode.previous = { row: current.row, col: current.col };\n\t\t\t\tif (neighborNode.type !== 'open') {\n\t\t\t\t\tneighborNode.type = 'open';\n\t\t\t\t\tgrid[neighborNode.row][neighborNode.col].type = 'open';\n\t\t\t\t\topen.push(neighborNode);\n\t\t\t\t\t// path = [...path, neighborNode];\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\tconsole.log('path not found');\n\n\treturn path;\n};\n\nconst sortByFCost = (open: INode[]) => {\n\t/**\n\t * sorting by fCost , if equal by hCost\n\t * a & b are flipped to sort it in descending order\n\t */\n\topen.sort((a, b) => {\n\t\tif (a.fCost !== b.fCost) return b.fCost - a.fCost;\n\t\treturn b.hCost - a.hCost;\n\t});\n};\n\nconst getNeighbors = (\n\trow: number,\n\tcol: number,\n\theight: number,\n\twidth: number,\n\tallowDiag = false,\n) => {\n\tlet list: { row: number; col: number }[] = [];\n\tfor (let i = -1; i < 2; i++) {\n\t\tfor (let j = -1; j < 2; j++) {\n\t\t\tif (!allowDiag && i !== 0 && j !== 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (i === 0 && j === 0) continue;\n\t\t\tif (row + i >= height || row + i < 0) continue;\n\t\t\tif (col + j >= width || col + j < 0) continue;\n\t\t\tlist = [...list, { row: row + i, col: col + j }];\n\t\t}\n\t}\n\n\treturn list;\n};\n\nconst distanceTo = (node: INode, end: INode) => {\n\tconst rowDifference = Math.abs(node.row - end.row);\n\tconst colDifference = Math.abs(node.col - end.col);\n\tif (!DIAG) {\n\t\treturn COST * (colDifference + rowDifference);\n\t}\n\t/**\n\t * if x > y : 14y + 10(x - y)\n\t */\n\tif (rowDifference > colDifference)\n\t\treturn DIAG_COST * colDifference + COST * (rowDifference - colDifference);\n\n\treturn DIAG_COST * rowDifference + COST * (colDifference - rowDifference);\n};\n","import React, { useState, useRef, ChangeEvent } from 'react';\n\nimport './Grid.css';\nimport { Node } from './node/Node';\nimport { INode, equalNodes, createNode } from './node/NodeInterface';\nimport { aStar } from '../Algorithm/A*';\nimport { randomWalls } from '../Algorithm/RandomWalls';\nimport { useCheckbox } from '../useCheckbox';\n\n// grid size\nconst W = 40;\nconst H = 20;\n// cursor and nodes\nconst START = 'start';\nconst END = 'end';\nconst WALL = 'wall';\n// animation Speed\nconst SLOW_SPEED = {\n\tSEARCH: 50,\n\tPATH: 100,\n};\nconst FAST_SPEED = {\n\tSEARCH: 20,\n\tPATH: 50,\n};\n\nexport const Grid = () => {\n\t// Helpers\n\tconst getInitialGrid = (defaultPoints: boolean = true) => {\n\t\tconst grid = [];\n\t\tfor (let row = 0; row < H; row++) {\n\t\t\tconst currentRow = [];\n\t\t\tfor (let col = 0; col < W; col++) {\n\t\t\t\tcurrentRow.push(createNode(row, col));\n\t\t\t\tif (defaultPoints) {\n\t\t\t\t\tif (row === H / 2 && col === 1) currentRow[col].type = START;\n\t\t\t\t\tif (row === H / 2 && col === W - 2) currentRow[col].type = END;\n\t\t\t\t}\n\t\t\t}\n\t\t\tgrid.push(currentRow);\n\t\t}\n\t\treturn grid;\n\t};\n\n\tconst toggleWall = (row: number, col: number) => {\n\t\tsetGrid(\n\t\t\tgrid.map(gRow =>\n\t\t\t\tgRow.map(gNode => {\n\t\t\t\t\tif (gNode.col !== col || gNode.row !== row) return gNode;\n\n\t\t\t\t\tif (gNode.type === WALL) gNode.type = ' ';\n\t\t\t\t\telse if (gNode.type === ' ') gNode.type = WALL;\n\t\t\t\t\treturn gNode;\n\t\t\t\t}),\n\t\t\t),\n\t\t);\n\t};\n\n\tconst placeSpecialNode = (row: number, col: number, type: string = START) => {\n\t\tconsole.log('place', type);\n\n\t\tsetGrid(\n\t\t\tgrid.map(gRow =>\n\t\t\t\tgRow.map(gNode => {\n\t\t\t\t\tif ((gNode.col !== col || gNode.row !== row) && gNode.type === type) {\n\t\t\t\t\t\tgNode.type = ' ';\n\t\t\t\t\t\treturn gNode;\n\t\t\t\t\t}\n\t\t\t\t\tif (gNode.type !== ' ') return gNode;\n\t\t\t\t\tif (gNode.col !== col || gNode.row !== row) return gNode;\n\n\t\t\t\t\tgNode.type = type;\n\t\t\t\t\tif (type === START) start.current = gNode;\n\t\t\t\t\tif (type === END) end.current = gNode;\n\t\t\t\t\treturn gNode;\n\t\t\t\t}),\n\t\t\t),\n\t\t);\n\t};\n\n\t/**\n\t * used to copy data from the result of the algorithm to the grid\n\t */\n\tconst inPath = (node: INode, path: INode[]) => {\n\t\tfor (let i = 0; i < path.length; i++) {\n\t\t\tconst n = path[i];\n\t\t\tif (n.col === node.col && n.row === node.row)\n\t\t\t\treturn {\n\t\t\t\t\tprevious: n.previous,\n\t\t\t\t\ttype: n.type,\n\t\t\t\t\tdelay: i * searchSpeed.current,\n\t\t\t\t};\n\t\t}\n\t\treturn null;\n\t};\n\tconst constructPath = (node: INode) => {\n\t\tlet path = [node];\n\t\tlet current = path[0];\n\t\twhile (current !== start.current) {\n\t\t\tconst parent = current.previous;\n\t\t\tif (parent === null) {\n\t\t\t\treturn path;\n\t\t\t}\n\t\t\tcurrent = grid[parent.row][parent.col];\n\t\t\tpath = [current, ...path];\n\t\t}\n\t\treturn path;\n\t};\n\n\tconst clearGrid = () => {\n\t\tsetGrid(\n\t\t\tgrid.map((row, i) =>\n\t\t\t\trow.map((node, j) => {\n\t\t\t\t\tnode = createNode(i, j);\n\n\t\t\t\t\tif (equalNodes(node, start.current)) node.type = START;\n\t\t\t\t\tif (equalNodes(node, end.current)) node.type = END;\n\n\t\t\t\t\treturn node;\n\t\t\t\t}),\n\t\t\t),\n\t\t);\n\t\tsetPathFound(false);\n\t};\n\tconst clearGridKeepWalls = () => {\n\t\tsetGrid(\n\t\t\tgrid.map((row, i) =>\n\t\t\t\trow.map((node, j) => {\n\t\t\t\t\tif (node.type !== WALL) {\n\t\t\t\t\t\tnode = createNode(i, j);\n\t\t\t\t\t}\n\t\t\t\t\tif (equalNodes(node, start.current)) node.type = START;\n\t\t\t\t\tif (equalNodes(node, end.current)) node.type = END;\n\n\t\t\t\t\treturn node;\n\t\t\t\t}),\n\t\t\t),\n\t\t);\n\t\tsetPathFound(false);\n\t};\n\n\t// events\n\tconst handleMouseDown = (row: number, col: number) => {\n\t\tsetMouseIsPressed(true);\n\n\t\tif (grid[row][col].type === START) {\n\t\t\tsetCursor(START);\n\t\t\treturn;\n\t\t}\n\t\tif (grid[row][col].type === END) {\n\t\t\tsetCursor(END);\n\t\t\treturn;\n\t\t}\n\n\t\tif (cursor === WALL) {\n\t\t\ttoggleWall(row, col);\n\t\t\treturn;\n\t\t}\n\t};\n\tconst handleMouseUpOrLeave = () => {\n\t\tsetMouseIsPressed(false);\n\t};\n\tconst handleMouseUp = (row: number, col: number) => {\n\t\tif (cursor === START) {\n\t\t\tplaceSpecialNode(row, col, START);\n\t\t\tsetCursor(WALL);\n\t\t}\n\t\tif (cursor === END) {\n\t\t\tplaceSpecialNode(row, col, END);\n\t\t\tsetCursor(WALL);\n\t\t}\n\t\tsetMouseIsPressed(false);\n\t};\n\n\tconst handleMouseEnter = (row: number, col: number) => {\n\t\tif (!mouseIsPressed) return;\n\n\t\tif (cursor === WALL) toggleWall(row, col);\n\t\tif (cursor === START) placeSpecialNode(row, col, START);\n\t\tif (cursor === END) placeSpecialNode(row, col, END);\n\t};\n\tconst handleVisualize = () => {\n\t\tconst cloneGrid = grid.map(row => row.map(node => node));\n\t\t// get the closed path\n\t\tconsole.log(allowDiag);\n\n\t\tconst path = aStar(\n\t\t\tcloneGrid,\n\t\t\tstart.current,\n\t\t\tend.current,\n\t\t\tallowDiag.checked,\n\t\t);\n\t\tif (path === undefined) {\n\t\t\treturn;\n\t\t}\n\n\t\tlet finalDelay = 0;\n\t\tsetGrid(\n\t\t\tgrid.map(gRow =>\n\t\t\t\tgRow.map(gNode => {\n\t\t\t\t\tconst res = inPath(gNode, path);\n\t\t\t\t\tif (res !== null) {\n\t\t\t\t\t\tgNode.type = res.type + '';\n\t\t\t\t\t\tgNode.delay = res.delay;\n\t\t\t\t\t\tgNode.previous = res.previous;\n\t\t\t\t\t\tfinalDelay = res.delay > finalDelay ? res.delay : finalDelay;\n\t\t\t\t\t}\n\t\t\t\t\t// keep the end node\n\t\t\t\t\tif (equalNodes(gNode, end.current)) {\n\t\t\t\t\t\tgNode.type = END;\n\t\t\t\t\t}\n\t\t\t\t\treturn gNode;\n\t\t\t\t}),\n\t\t\t),\n\t\t);\n\t\tsetPathFound(true);\n\t\tif (!equalNodes(path[path.length - 1], end.current)) {\n\t\t\talert('no path found');\n\t\t\treturn;\n\t\t}\n\n\t\tconst shortestPath = constructPath(path[path.length - 2]);\n\t\t// animate shortest path\n\t\tsetTimeout(() => {\n\t\t\tsetGrid(\n\t\t\t\tgrid.map(gRow =>\n\t\t\t\t\tgRow.map(gNode => {\n\t\t\t\t\t\tconst i = shortestPath.indexOf(gNode);\n\t\t\t\t\t\tif (i > -1) {\n\t\t\t\t\t\t\tif (gNode.type !== START && gNode.type !== END) {\n\t\t\t\t\t\t\t\tgNode.type = 'path';\n\t\t\t\t\t\t\t\tgNode.delay = i * pathSpeed.current;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn gNode;\n\t\t\t\t\t}),\n\t\t\t\t),\n\t\t\t);\n\t\t}, finalDelay + 500);\n\t};\n\n\tconst handleRandomMaze = () => {\n\t\tconst newGrid = randomWalls(W, H);\n\t\tclearGrid();\n\t\tsetTimeout(() => {\n\t\t\tsetGrid(\n\t\t\t\tgrid.map((gRow, i) =>\n\t\t\t\t\tgRow.map((gNode, j) => {\n\t\t\t\t\t\tgNode = createNode(i, j);\n\n\t\t\t\t\t\tif (equalNodes(gNode, start.current)) {\n\t\t\t\t\t\t\tgNode.type = START;\n\t\t\t\t\t\t\treturn gNode;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (equalNodes(gNode, end.current)) {\n\t\t\t\t\t\t\tgNode.type = END;\n\t\t\t\t\t\t\treturn gNode;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst res = newGrid[i][j];\n\t\t\t\t\t\tif (!res.wall) {\n\t\t\t\t\t\t\treturn gNode;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tgNode.type = WALL;\n\t\t\t\t\t\tgNode.delay = res.delay;\n\n\t\t\t\t\t\treturn gNode;\n\t\t\t\t\t}),\n\t\t\t\t),\n\t\t\t);\n\t\t}, 20);\n\t};\n\tconst handleSpeedChange = (event: ChangeEvent<HTMLSelectElement>) => {\n\t\tconsole.log(event.target.value);\n\n\t\tif (event.target.value === 'fast') {\n\t\t\tsearchSpeed.current = FAST_SPEED.SEARCH;\n\t\t\tpathSpeed.current = FAST_SPEED.PATH;\n\t\t}\n\t\tif (event.target.value === 'slow') {\n\t\t\tsearchSpeed.current = SLOW_SPEED.SEARCH;\n\t\t\tpathSpeed.current = SLOW_SPEED.PATH;\n\t\t}\n\t};\n\t// state & refs\n\tconst [grid, setGrid] = useState(getInitialGrid());\n\tconst start = useRef(grid[H / 2][1]);\n\tconst end = useRef(grid[H / 2][W - 2]);\n\tconst [mouseIsPressed, setMouseIsPressed] = useState(false);\n\tconst [cursor, setCursor] = useState(WALL);\n\tconst searchSpeed = useRef(FAST_SPEED.SEARCH);\n\tconst pathSpeed = useRef(FAST_SPEED.PATH);\n\tconst allowDiag = useCheckbox(false);\n\tconst [pathFound, setPathFound] = useState(false);\n\n\treturn (\n\t\t<div\n\t\t\tclassName='layout'\n\t\t\tonMouseUp={handleMouseUpOrLeave}\n\t\t\tonMouseLeave={handleMouseUpOrLeave}\n\t\t>\n\t\t\t<div className='main columns'>\n\t\t\t\t<div className='right-side column'>\n\t\t\t\t\t<div className='btn-section'>\n\t\t\t\t\t\t<div className='subtitle is-6'>Visualize Algorithm</div>\n\t\t\t\t\t\t<div className='field mb-3'>\n\t\t\t\t\t\t\t<div className='control'>\n\t\t\t\t\t\t\t\t<label htmlFor='select'>Speed : </label>\n\t\t\t\t\t\t\t\t<div className='select is-small'>\n\t\t\t\t\t\t\t\t\t<select defaultValue='fast' onChange={handleSpeedChange}>\n\t\t\t\t\t\t\t\t\t\t<option value='slow'>Slow</option>\n\t\t\t\t\t\t\t\t\t\t<option value='fast'>Fast</option>\n\t\t\t\t\t\t\t\t\t</select>\n\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t<label className='checkbox'>\n\t\t\t\t\t\t\t\t<input type='checkbox' {...allowDiag} />\n\t\t\t\t\t\t\t\tAllow Diagonal\n\t\t\t\t\t\t\t</label>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t\t<button\n\t\t\t\t\t\t\tclassName='button'\n\t\t\t\t\t\t\tonClick={handleVisualize}\n\t\t\t\t\t\t\tdisabled={pathFound}\n\t\t\t\t\t\t>\n\t\t\t\t\t\t\tA*\n\t\t\t\t\t\t</button>\n\t\t\t\t\t\t<div className='subtitle is-6'>Grid</div>\n\t\t\t\t\t\t<div className='button' onClick={clearGrid}>\n\t\t\t\t\t\t\tClear Walls\n\t\t\t\t\t\t</div>\n\t\t\t\t\t\t<div className='button' onClick={clearGridKeepWalls}>\n\t\t\t\t\t\t\tReset Path\n\t\t\t\t\t\t</div>\n\t\t\t\t\t\t<div className='subtitle is-6'>Maze Generation</div>\n\t\t\t\t\t\t<div className='button' onClick={handleRandomMaze}>\n\t\t\t\t\t\t\tRandom\n\t\t\t\t\t\t</div>\n\t\t\t\t\t</div>\n\t\t\t\t</div>\n\n\t\t\t\t<div\n\t\t\t\t\tclassName='grid box column is-12 is-9-desktop'\n\t\t\t\t\t// style={{ width: W * 26 + 'px' }}\n\t\t\t\t>\n\t\t\t\t\t{grid.map((row, i) => (\n\t\t\t\t\t\t<div className='row' key={i}>\n\t\t\t\t\t\t\t{row.map((node, j) => {\n\t\t\t\t\t\t\t\treturn (\n\t\t\t\t\t\t\t\t\t<Node\n\t\t\t\t\t\t\t\t\t\tdata={node}\n\t\t\t\t\t\t\t\t\t\tmouseDown={handleMouseDown}\n\t\t\t\t\t\t\t\t\t\tmouseUp={handleMouseUp}\n\t\t\t\t\t\t\t\t\t\tmouseEnter={handleMouseEnter}\n\t\t\t\t\t\t\t\t\t\tkey={i + ',' + j}\n\t\t\t\t\t\t\t\t\t></Node>\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t})}\n\t\t\t\t\t\t</div>\n\t\t\t\t\t))}\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t</div>\n\t);\n};\n","import { useState } from 'react';\n\nexport const useCheckbox = (initial: boolean) => {\n\tconst [checked, setValue] = useState(initial);\n\tconst onChange = (e: React.ChangeEvent<any>) => {\n\t\tsetValue(!checked);\n\t};\n\n\treturn {\n\t\tchecked,\n\t\tonChange,\n\t};\n};\n","export const randomWalls: (\n\tcols: number,\n\trows: number,\n) => {\n\twall: boolean;\n\tdelay: number;\n}[][] = (cols: number, rows: number) => {\n\tconst grid = [];\n\tfor (let row = 0; row < rows; row++) {\n\t\tconst currentRow = [];\n\t\tfor (let col = 0; col < cols; col++) {\n\t\t\tcurrentRow.push({\n\t\t\t\twall: false,\n\t\t\t\tdelay: 0,\n\t\t\t});\n\t\t\tif (Math.random() < 0.5) {\n\t\t\t\tcurrentRow[col].delay = (col + row) * 50;\n\t\t\t\tcurrentRow[col].wall = true;\n\t\t\t}\n\t\t}\n\t\tgrid.push(currentRow);\n\t}\n\treturn grid;\n};\n","import React from 'react';\n// import logo from './logo.svg';\nimport './App.css';\nimport { Grid } from './components/grid/Grid';\n\nfunction App() {\n\treturn (\n\t\t<div className='App'>\n\t\t\t<Grid></Grid>\n\t\t</div>\n\t);\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport '../node_modules/bulma/css/bulma.css';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n\t<React.StrictMode>\n\t\t<App />\n\t</React.StrictMode>,\n\tdocument.getElementById('root'),\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}